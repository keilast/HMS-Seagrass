---
title: "Beyond a single patch: local and regional processes explain diversity patterns in a seagrass epifaunal metacommunity, by Stark, K. A., P. L. Thompson, J. Yakimishyn, L. Lee, M. I. O'Connor."
author: "Code by Keila Stark"
date: '2018-09-30'
output:  
  pdf_document: default
  html_document: default
---

```=
setwd("~/Documents/seagrass_metacom_paper")
```

## Load packages

```{packages}
install.packages('devtools')
install.packages('Rcpp')
install.packages('RcppArmadillo')
install.packages('coda')
install.packages('beanplot')
install.packages('circlize')
install.packages('corrplot')
install.packages('coda')
install.packages('dendextend')
install_github('guiblanchet/HMSC')

library(devtools)
library(HMSC)
library(vegan)
library(tidyverse)
library(viridis)
library(corrplot)
library(RColorBrewer)
library(dendextend)
```

#### HMSC ANALYSIS ------------------------------------------------------------

1. READ IN AND PREPARE DATA

```{r, echo=FALSE}
READ IN AND PREPARE DATA

Y <- read.csv("Y_matrix.csv", header = TRUE, stringsAsFactors = FALSE) # Site-by-sp matrix (Y)
rownames(Y) <- Y[,1]

X <- read.csv("X_matrix.csv", header = TRUE, stringsAsFactors = FALSE) # Environmental covariate matrix (X)
X <- X[,-c(7,8,10)]
rownames(X) <- Y[,1]

spatial <- read.csv("coords.csv", header = TRUE, stringsAsFactors = FALSE) # lat&long coordinates
rownames(spatial) <- Y[,1]

Pi <- read.csv("pi.csv", header = TRUE, stringsAsFactors = FALSE) #factors representing random effects
Pi <- data.frame(apply(Pi,2,as.factor))

Y <- Y[,-1] #remove actual site names from Y matrix

## Remove NA's get into right format for as.HMSCdata to work
X[is.na(X)] <- 0
Y[is.na(Y)] <- 0
Y <- as.matrix(Y)
X <- as.matrix(X)
spatial <- as.data.frame(spatial)
spatial <- spatial[,-1]
```
 

#### 3. CREATE HMSCdata OBJECT WITH THE ABOVE 4 INPUT MATRICES, GENERATE MODEL 

```{r, echo=FALSE}

#Create HMSCdata object with the above four input matrices
hmsc1 <- as.HMSCdata(Y = Y, X = X, Random = Pi, Auto = spatial)
envonly <- as.HMSCdata(Y = Y, X = X, Random = Pi)
spaceonly <- as.HMSCdata(Y = Y, Random = Pi, Auto = spatial)

# set prior distribution
hmscprior <- as.HMSCprior(hmsc1)
hmscparam <- as.HMSCparam(hmsc1, hmscprior)
envprior <- as.HMSCprior(envonly)
envparam <- as.HMSCparam(envonly,envprior)
spaceprior <- as.HMSCprior(spaceonly)
spaceparam <- as.HMSCparam(spaceonly, spaceprior)

## Generate the hierarchical joint species distribution model with MCMC. We used 200000 interations, as the developers of the method note that Poisson distributions sometimes require 10-100 times more iterations to accurately estimate the model's parameters
model <- hmsc(hmsc1, family = "poisson", niter = 100000, nburn = 1000,
              thin = 100)
envmod <-  hmsc(envonly, family = "poisson", niter = 100000, nburn = 1000,
                thin = 100)
spacemod <-  hmsc(spaceonly, family = "poisson", niter = 100000, nburn = 1000,
                  thin = 100)
## Note the three separate models- the main model we will use is the global model entitled "model", however the environmental (envmod) and spatial models (spacemod) will be used for the variation partitioning calculation reported in the main text and showed in the Venn diagram in Fig. S3, Supporting Information

```

### 3. Produce mixing, trace, density plots to look at model performance
### Note: None of the figures/ results from this section are included in the paper. This is for assessing your model performance. 
```{r, echo=FALSE}
##Producing MCMC traceplots
mixing <- as.mcmc(model, parameters = "paramX") #Mixing object

### Draw trace and density plots for all combination of parameters
plot(mixing)

### Convert the mixing object to a matrix
mixingDF <- as.data.frame(mixing)

### Draw beanplots
library(beanplot)
par(mar = c(7, 4, 4, 2))
beanplot(mixingDF, las = 2)
### Draw boxplot for each parameters
par(mar = c(7, 4, 4, 2))
boxplot(mixingDF, las = 2)
### True values
truth <- as.vector(simulParamEx1$param$paramX)
### Average
average <- apply(model$results$estimation$paramX, 1:2, mean)
### 95% confidence intervals
CI.025 <- apply(model$results$estimation$paramX, 1:2, quantile, probs=0.025)
CI.975 <- apply(model$results$estimation$paramX, 1:2, quantile, probs=0.975)
CI <- cbind(as.vector(CI.025), as.vector(CI.975))
### Draw confidence interval plots
plot(0, 0, xlim = c(1, nrow(CI)), ylim = range(CI, truth), type = "n",
     xlab = "", ylab = "", main="paramX")
abline(h = 0,col = "grey")
arrows(x0 = 1:nrow(CI), x1 = 1:nrow(CI), y0 = CI[, 1], y1 = CI[, 2],
       code = 3, angle = 90, length = 0.05)
points(1:nrow(CI), average, pch = 15, cex = 1.5)
points(1:nrow(CI), truth, col = "red", pch = 19)
### Summary table
paramXCITable <- cbind(unlist(as.data.frame(average)),
                       unlist(as.data.frame(CI.025)),
                       unlist(as.data.frame(CI.975)))
colnames(paramXCITable) <- c("paramX", "lowerCI", "upperCI")
rownames(paramXCITable) <- paste(rep(colnames(average),
                                     each = nrow(average)), "_",
                                 rep(rownames(average),
                                     ncol(average)), sep="")
```



#### 4. COMPUTE MODEL FIT (D2adj or Explained Deviance)
###3 Values shown in Table S2: Supporting Information

### Code generously provided by Petr Keil & Duarte Viana, November 2018

# Poisson deviance
# Arguments:
# Y - the observations
# mu - the predicted means (of Poisson distribution)

```{r, echo=FALSE}
Poisson.deviance <- function(Y, mu)
{
  2*sum(ifelse(Y == 0, 
               -(Y-mu), # when the observation is 0
               Y*log(Y/mu) - (Y-mu))) # else
}

PD <- Poisson.deviance(Y, pred.hmsc)

# Explained deviance calculated for each species, then averaged
D2.avg.Poisson <- function(Y.obs, Y.pred)
{
  Y <- as.matrix(Y.obs)
  mu <- as.matrix(Y.pred) # we assume that the predicted values are the Poisson mu
  
  resid.devs <- null.devs <- numeric(ncol(Y))
  for(i in 1:ncol(Y))
  {
    resid.devs[i] <- Poisson.deviance(Y[,i], mu[,i])
    null.devs[i]  <- Poisson.deviance(Y[,i], mean(Y[,i]))
  }
  
  D2s <- 1 - resid.devs/null.devs
  D2s[D2s < 0] <- 0 # change negative values to 0
  D2s[is.nan(D2s)] <-0
  D2 <- mean(D2s)
  
  return(D2)
}

# This version of the funciton does the same thing but returns a vector of D2 values rather than one mean
D2.Poisson <- function(Y.obs, Y.pred)
{
  Y <- as.matrix(Y.obs)
  mu <- as.matrix(Y.pred) 
  
  resid.devs <- null.devs <- numeric(ncol(Y))
  for(i in 1:ncol(Y))
  {
    resid.devs[i] <- Poisson.deviance(Y[,i], mu[,i])
    null.devs[i]  <- Poisson.deviance(Y[,i], mean(Y[,i]))
  }
  
  D2s <- 1 - resid.devs/null.devs
  D2s[D2s < 0] <- 0 # change negative values to 0
  
  
  return(D2s) 
}


# Use with HMSC: Y is the species matrix, pred.hmsc is the predicted species matrix
pred.hmsc <- predict(model)
R2 <- D2.avg.Poisson(Y, pred.hmsc) #single average community level value
D2 <- D2.Poisson(Y, pred.hmsc) #value for each species

plot(x=pre,y=D2,xlab="Average quadrat-level abundance",ylab="Predictive power (Pseudo R2)") ## can plot against abundance to visualize D2 for each spp if desired
```



#### VARIATION PARTITIONING OF SPATIAL RANDOM EFFECTS AND ENVIRONMENTAL VARIABLES (Fig. 2)----------

# First conduct variation partitioning/ create object summarizing result for global model...

```{r, echo = FALSE}
varpart <- variPart(model, c(rep("Habitat structure",3),rep("Food availability",3), rep("Fetch",1),rep("Dissolved O2",1),rep("Salinity",1),rep("pH",1),rep("Mean Temp",1), rep("Nitrates",1),rep("Phosphates",1), rep("Silicates",1),rep("Chl a",1)))

# Environment only
varpartenv <- variPart(envmod, c(rep("Habitat structure",3),rep("Food availability",3), rep("Fetch",1),rep("Dissolved O2",1),rep("Salinity",1),rep("pH",1),rep("Mean Temp",1), rep("Nitrates",1),rep("Phosphates",1), rep("Silicates",1),rep("Chl a",1)))

# Space only
varpartspatial<- variPart(spacemod, c(rep("intercept",1)))

# Now take the mean variance explained by the global model and each independent model 
spatmeans <- colMeans(varpartspatial) 
envmeans <- colMeans(varpartenv) 
wholemeans <- colMeans(varpart)
```
## Use these values to calculate different fractions of variation explained 
## (See "manual_varpart.xlsx" for detailed description)
## The output of these calculations is the Venn Diagram in Fig. S3, Supporting Information

---------

#Now we are going to create the variation partitioning barplot in Fig. 2 - using the Global Model only
```{r, echo=FALSE}

par(mar=c(2.5,3,2.5,12.7)) ## set margins to make space for sp and variable labels
par(xpd = FALSE)

# Create the figure. The interesting spacing scheme is to separate broad taxonomic groupings.
barplot(t(varpart), las=2, cex.names=0.75, cex.axis=0.75, col = c("springgreen4" , "yellow2",  "#31688EFF", "#31688EF2", "#31688EE6", "#31688ED9", "#31688ECC", "#31688EBF", "#31688EB3", "#31688EA6", "#31688E99", "#440154FF", "#44015480", "black"),  space = c(0,0,0,0,0,0,0,0,0,0,0,0,0.6,0,0,0,0,0.6,0,0,0,0,0,0,0,0,0.6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.6,0,0,0.6,0.6,0.6,0.6,0,0,0,0.6,0.6,0,0,0.6,0,0.6), 
        legend.text=paste(colnames(variationPart)," ",
                          signif(100*colMeans(variationPart),2),"%",sep=""),
        args.legend=list(y=1.01, xjust=0.023, horiz=F, bty="n",cex=0.77)) 


```



#### PLOT DISTANCE-DECAY OF COMMUNITY SIMILARITY (Fig. 1b) ---------------------
```{r, echo=FALSE}
library(RColorBrewer) ### Plot Fig 1b
n <- nrow(hmsc1$X)
hmsc11 <- hmsc1
hmsc11$X <- matrix(rep(colMeans(11$X),each=n),
                      nrow=n,ncol=ncol(hmsc11$X))

# Set and make predictions (ie. predicted similarity based on geographic distance btwn sites)
npred <- 3003

predAll <- array(NA,dim=list(nrow(hmsc1$Y),ncol(hmsc1$Y),npred))
predAll2 <- array(NA,dim=list(nrow(hmsc11$Y),ncol(hmsc11$Y),npred))
for (i in 1:npred) {
  predAll[,,i] <- predict(model, newdata=hmsc1)
  predAll2[,,i] <- predict(model, newdata=hmsc11)
}
pred <- apply(predAll,c(1,2),mean)
pred2 <- apply(predAll2,c(1,2),mean)


# Plot community similarity as a function of distance, based on pairs of different points
nrepls <- 150
ta <- matrix(0,nrow=nrepls,ncol=3)
for (i in 1:nrepls) {
  s1s2 <- sample(1:nrow(hmsc1$X),2)
  s1 <- s1s2[1]
  s2 <- s1s2[2]
  ta[i,1] <- sqrt(sum((hmsc1$Auto[[1]][s1,2:3]-hmsc1$Auto[[1]][s2,2:3])^2))
  ta[i,2] <- cor(pred[s1,], pred[s2,])
  ta[i,3] <- cor(pred[s1,], pred2[s2,])
}
maxd <- max(ta[,1],na.rm=T)

plot.new()
par(mar = c(4,4,1,1))
par(oma = c(4, 1, 1, 1))
wop <- ta[,1]*111
plot(x=wop,y=ta[,2],pch=1,col="firebrick",xlab="Pairwise site distance (km)",ylab="Predicted community similarity")
lines(y=predict(lm(ta[,2]~ta[,1])),x=wop,col="firebrick",  lwd = 3)
points(x=wop,y=ta[,3],pch=2,col="cyan3",xaxt='n',yaxt="n")
lines(y=predict(lm(ta[,3]~ta[,1])),x=wop,col="cyan3",lwd = 3)
legend("bottomright", legend=c("Space + environmental covariates","Space only"),col=c("firebrick","cyan3") ,cex= 0.75, pch=c(1,2), xpd = NA, inset = c(.5,-.5), bty = "n")



```


### Made a modified version of the Imagine function from the metacom package to fill cells with colour based on which co-occurrence grouping they belonged to (from Ward D2 cluster analysis on HMSC model)
### Function names are imagine1() [Greys] imagine2() [Turquoise] and imagine3() [Purples]

```{r, echo=FALSE}
imagine1 <- function (comm, col = col, fill = TRUE, 
                      xlab = "", ylab = "", yline = 2, xline = 2, sitenames = rownames(comm), 
                      speciesnames = colnames(comm), binary = TRUE) 
{
  reverse <- nrow(comm):1
  comm <- comm[reverse, ]
  par(mar = c(1, 6, 15, 1))
  
  image(1:dim(comm)[2], 1:dim(comm)[1], t(comm), grs = c("#00000000","#52525203","#52525205","#52525208","#5252520A","#5252520D","#5252520F","#52525212","#52525214","#52525217","#5252521A","#5252521C","#5252521F","#52525221","#52525224","#52525226","#52525229","#5252522B","#5252522E","#52525230","#52525233","#52525236","#52525238","#5252523B","#5252523D","#52525240","#52525242","#52525245","#52525247","#5252524A","#5252524D","#5252524F","#52525252","#52525254","#52525257","#52525259","#5252525C","#5252525E","#52525261","#52525263","#52525266","#52525269","#5252526B","#5252526E","#52525270","#52525273","#52525275","#52525278","#5252527A","#5252527D","#52525280","#52525282","#52525285","#52525287","#5252528A","#5252528C","#5252528F","#52525291","#52525294","#52525296","#52525299","#5252529C","#5252529E","#525252A1","#525252A3","#525252A6","#525252A8","#525252AD","#525252B0","#525252B3","#525252B5","#525252B8","#525252BA","#525252BD","#525252BF","#525252C2","#525252C4","#525252C7","#525252C9","#525252CC","#525252CF","#525252D1","#525252D4","#525252D6","#525252D9","#525252DB","#525252DE","#525252E0","#525252E3","#525252E6","#525252E8","#525252EB","#525252ED","#525252F0","#525252F2","#525252F5","#525252F7","#525252FA","#525252FC"), xlab = "", ylab = "", axes = FALSE)
  box()
  if (length(sitenames) > 1) {
    axis(2, at = 1:dim(comm)[1], labels = sitenames, las = 1, 
         cex.axis = 1, lwd.ticks = 0)
  }
  if (length(speciesnames) > 1) {
    axis(3, at = 1:dim(comm)[2], labels = speciesnames, las = 2, 
         cex.axis = 1, lwd.ticks = 0)
  }
  mtext(xlab, 3, cex = 1.5, line = xline)
  mtext(ylab, 2, cex = 1.5, line = yline)
}

imagine2 <- function (comm, col = col, fill = TRUE, 
                      xlab = "", ylab = "", yline = 2, xline = 2, sitenames = rownames(comm), 
                      speciesnames = colnames(comm), binary = TRUE, add = TRUE) 
{
  reverse <- nrow(comm):1
  comm <- comm[reverse, ]
  par(mar = c(1, 6, 15, 1))
  
  image(1:dim(comm)[2], 1:dim(comm)[1], t(comm), col = c("#00000000","#21908C03","#21908C05","#21908C08","#21908C0A","#21908C0D","#21908C0F","#21908C12","#21908C14","#21908C17","#21908C1A","#21908C1C","#21908C1F","#21908C21","#21908C24","#21908C26","#21908C29","#21908C2B","#21908C2E","#21908C30","#21908C33","#21908C36","#21908C38","#21908C3B","#21908C3D","#21908C40","#21908C42","#21908C45","#21908C47","#21908C4A","#21908C4D","#21908C4F","#21908C52","#21908C54","#21908C57","#21908C59","#21908C5C","#21908C5E","#21908C61","#21908C63","#21908C66","#21908C69","#21908C6B","#21908C6E","#21908C70","#21908C73","#21908C75","#21908C78","#21908C7A","#21908C7D","#21908C80","#21908C82","#21908C85","#21908C87","#21908C8A","#21908C8C","#21908C8F","#21908C91","#21908C94","#21908C96","#21908C99","#21908C9C","#21908C9E","#21908CA1","#21908CA3","#21908CA6","#21908CA8","#21908CAD","#21908CB0","#21908CB3","#21908CB5","#21908CB8","#21908CBA","#21908CBD","#21908CBF","#21908CC2","#21908CC4","#21908CC7","#21908CC9","#21908CCC","#21908CCF","#21908CD1","#21908CD4","#21908CD6","#21908CD9","#21908CDB","#21908CDE","#21908CE0","#21908CE3","#21908CE6","#21908CE8","#21908CEB","#21908CED","#21908CF0","#21908CF2","#21908CF5","#21908CF7","#21908CFA","#21908CFC"), xlab = "", ylab = "", axes = FALSE, add = TRUE)
  box()
  if (length(sitenames) > 1) {
    axis(2, at = 1:dim(comm)[1], labels = sitenames, las = 1, 
         cex.axis = 1, lwd.ticks = 0)
  }
  if (length(speciesnames) > 1) {
    axis(3, at = 1:dim(comm)[2], labels = speciesnames, las = 2, 
         cex.axis = 1, lwd.ticks = 0)
  }
  mtext(xlab, 3, cex = 1.5, line = xline)
  mtext(ylab, 2, cex = 1.5, line = yline)
}

imagine3 <- function (comm, col = col, fill = TRUE, 
                      xlab = "", ylab = "", yline = 2, xline = 2, sitenames = rownames(comm), 
                      speciesnames = colnames(comm), binary = TRUE, add = TRUE) 
{
  reverse <- nrow(comm):1
  comm <- comm[reverse, ]
  par(mar = c(1, 6, 15, 1))
  
  image(1:dim(comm)[2], 1:dim(comm)[1], t(comm), col = c("#00000000","#44015403","#44015405","#44015408","#4401540A","#4401540D","#4401540F","#44015412","#44015414","#44015417","#4401541A","#4401541C","#4401541F","#44015421","#44015424","#44015426","#44015429","#4401542B","#4401542E","#44015430","#44015433","#44015436","#44015438","#4401543B","#4401543D","#44015440","#44015442","#44015445","#44015447","#4401544A","#4401544D","#4401544F","#44015452","#44015454","#44015457","#44015459","#4401545C","#4401545E","#44015461","#44015463","#44015466","#44015469","#4401546B","#4401546E","#44015470","#44015473","#44015475","#44015478","#4401547A","#4401547D","#44015480","#44015485","#44015487","#4401548A","#4401548C","#4401548F","#44015491","#44015494","#44015496","#44015499","#4401549C","#4401549E","#440154A1","#440154A3","#440154A6","#440154A8","#440154AD","#440154B0","#440154B3","#440154B5","#440154B8","#440154BA","#440154BD","#440154BF","#440154C2","#440154C4","#440154C7","#440154C9","#440154CC","#440154CF","#440154D1","#440154D4","#440154D6","#440154D9","#440154DB","#440154DE","#440154E0","#440154E3","#440154E6","#440154E8","#440154EB","#440154ED","#440154F0","#440154F2","#440154F5","#440154F7","#440154FA","#440154FC"), xlab = "", ylab = "", axes = FALSE, add = TRUE)
  box()
  if (length(sitenames) > 1) {
    axis(2, at = 1:dim(comm)[1], labels = sitenames, las = 1, 
         cex.axis = 1, lwd.ticks = 0)
  }
  if (length(speciesnames) > 1) {
    axis(3, at = 1:dim(comm)[2], labels = speciesnames, las = 2, 
         cex.axis = 1, lwd.ticks = 0)
  }
  mtext(xlab, 3, cex = 1.5, line = xline)
  mtext(ylab, 2, cex = 1.5, line = yline)
}

```

## read them back in after editing in excel 
grays_only3 <- read.csv("grays_only3.csv", header = TRUE, stringsAsFactors = FALSE)
row.names(grays_only3) <- grays_only3[,1]
grays_only3 <- grays_only3[,2:56]


blues_only3 <- read.csv("blues_only3.csv", header = TRUE, stringsAsFactors = FALSE)
row.names(blues_only3) <- blues_only3[,1]
blues_only3 <- blues_only3[,2:56]


purples_only3 <- read.csv("purples_only3.csv", header = TRUE, stringsAsFactors = FALSE)
row.names(purples_only3) <- purples_only3[,1]
purples_only3 <- purples_only3[,2:56]

## Do this again for log transformed stuff 

log_grays_only <- read.csv("log_grays_only.csv", header = TRUE, stringsAsFactors = FALSE)
row.names(log_grays_only) <- log_grays_only[,1]
log_grays_only1 <- log_grays_only[,2:56]


log_blues_only <- read.csv("log_blues_only.csv", header = TRUE, stringsAsFactors = FALSE)
row.names(log_blues_only) <- log_blues_only[,1]
log_blues_only1 <- log_blues_only[,2:56]


log_purples_only <- read.csv("log_purples_only.csv", header = TRUE, stringsAsFactors = FALSE)
row.names(log_purples_only) <- log_purples_only[,1]
log_purples_only1 <- log_purples_only[,2:56]




imagine1(grays_only3)
imagine2(subblues)
imagine3(subpurples)

imagine1(log_grays_only1)
imagine2(log_blues_only1)
imagine3(log_purples_only1)

imagine1(subgreys)
imagine2(subblues)
imagine3(subpurples)

#### PLOT SPECIES-TO-SPECIES CORRELATION MATRIX (Fig. 3a)
```{r, echo=FALSE}
corMat <- corRandomEff(model, cor =TRUE)
averageCor <- apply(corMat[ ,,,2], 1:2, mean)
corrplot(averageCor, method = "color", col = colorRampPalette(c("#21908C","white","#440154"))(200), order = "hclust", hclust.method = "average", tl.col = "black", tl.cex = 0.8)
```




### Create Fig. 3b: Subset species by colour grouping according to correlation matrix in Fig. 3a. 

```{r, echo=FALSE}
sub_com_ordered <- read.csv("subcomfinal.csv", header = TRUE, stringsAsFactors = FALSE)
rownames(sub_com_ordered) <- sub_com_ordered[,1]
sub_com_ordered <- sub_com_ordered[,-1]
sub_com_ordered <- as.matrix(sub_com_ordered)


subblues1 <- matrix(nrow = nrow(sub_com_ordered), ncol=ncol(sub_com_ordered))
subblues1[,c(1,3,4,8,9,10,11,13,15,17,18,19,20)] <- sub_com_ordered[,c(1,3,4,8,9,10,11,13,15,17,18,19,20)]
subblues1[,-c(1,3,4,8,9,10,11,13,15,17,18,19,20)]  <- 0
rownames(subblues1) <- rownames(sub_com_ordered)
colnames(subblues1) <- colnames(sub_com_ordered)


subpurples1 <- matrix(nrow = nrow(sub_com_ordered), ncol=ncol(sub_com_ordered))
subpurples1[,c(2,6,7,12,14,16)] <- sub_com_ordered[,c(2,6,7,12,14,16)]
subpurples1[,-c(2,6,7,12,14,16)] <- 0
rownames(subpurples1) <- rownames(sub_com_ordered)
colnames(subpurples1) <- colnames(sub_com_ordered)

subgreys1 <- matrix(nrow = nrow(sub_com_ordered), ncol=ncol(sub_com_ordered))
subgreys1[,5] <- sub_com_ordered[,5]
subgreys1[,-5] <- 0
rownames(subgreys1) <- rownames(sub_com_ordered)
colnames(subgreys1) <- colnames(sub_com_ordered)

## Specify 3 more custom functions to populate image with colour groupings (imagine4-6)

imagine4 <- function (comm, col = col, fill = TRUE, 
                      xlab = "", ylab = "", yline = 2, xline = 2, sitenames = rownames(comm), 
                      speciesnames = colnames(comm), binary = TRUE) 
{
  reverse <- nrow(comm):1
  comm <- comm[reverse, ]
  par(mar = c(1, 3.5, 11.2, 8))
  
  image(1:dim(comm)[2], 1:dim(comm)[1], t(comm), col = c("#00000000","#52525203","#52525205","#52525208","#5252520A","#5252520D","#5252520F","#52525212","#52525214","#52525217","#5252521A","#5252521C","#5252521F","#52525221","#52525224","#52525226","#52525229","#5252522B","#5252522E","#52525230","#52525233","#52525236","#52525238","#5252523B","#5252523D","#52525240","#52525242","#52525245","#52525247","#5252524A","#5252524D","#5252524F","#52525252","#52525254","#52525257","#52525259","#5252525C","#5252525E","#52525261","#52525263","#52525266","#52525269","#5252526B","#5252526E","#52525270","#52525273","#52525275","#52525278","#5252527A","#5252527D","#52525280","#52525282","#52525285","#52525287","#5252528A","#5252528C","#5252528F","#52525291","#52525294","#52525296","#52525299","#5252529C","#5252529E","#525252A1","#525252A3","#525252A6","#525252A8","#525252AD","#525252B0","#525252B3","#525252B5","#525252B8","#525252BA","#525252BD","#525252BF","#525252C2","#525252C4","#525252C7","#525252C9","#525252CC","#525252CF","#525252D1","#525252D4","#525252D6","#525252D9","#525252DB","#525252DE","#525252E0","#525252E3","#525252E6","#525252E8","#525252EB","#525252ED","#525252F0","#525252F2","#525252F5","#525252F7","#525252FA","#525252FC"), xlab = "", ylab = "", axes = FALSE)
  box()
  if (length(sitenames) > 1) {
    axis(2, at = 1:dim(comm)[1], labels = sitenames, las = 1, 
         cex.axis = 1, lwd.ticks = 0)
  }
  if (length(speciesnames) > 1) {
    axis(3, at = 1:dim(comm)[2], labels = speciesnames, las = 2, 
         cex.axis = 1, lwd.ticks = 0)
  }
  mtext(xlab, 3, cex = 1.5, line = xline)
  mtext(ylab, 2, cex = 1.5, line = yline)
}

imagine5 <- function (comm, col = col, fill = TRUE, 
                      xlab = "", ylab = "", yline = 2, xline = 2, sitenames = rownames(comm), 
                      speciesnames = colnames(comm), binary = TRUE, add = TRUE) 
{
  reverse <- nrow(comm):1
  comm <- comm[reverse, ]
  par(mar = c(1, 3.5, 11.2, 8))
  
  image(1:dim(comm)[2], 1:dim(comm)[1], t(comm), col = c("#00000000","#21908C03","#21908C05","#21908C08","#21908C0A","#21908C0D","#21908C0F","#21908C12","#21908C14","#21908C17","#21908C1A","#21908C1C","#21908C1F","#21908C21","#21908C24","#21908C26","#21908C29","#21908C2B","#21908C2E","#21908C30","#21908C33","#21908C36","#21908C38","#21908C3B","#21908C3D","#21908C40","#21908C42","#21908C45","#21908C47","#21908C4A","#21908C4D","#21908C4F","#21908C52","#21908C54","#21908C57","#21908C59","#21908C5C","#21908C5E","#21908C61","#21908C63","#21908C66","#21908C69","#21908C6B","#21908C6E","#21908C70","#21908C73","#21908C75","#21908C78","#21908C7A","#21908C7D","#21908C80","#21908C82","#21908C85","#21908C87","#21908C8A","#21908C8C","#21908C8F","#21908C91","#21908C94","#21908C96","#21908C99","#21908C9C","#21908C9E","#21908CA1","#21908CA3","#21908CA6","#21908CA8","#21908CAD","#21908CB0","#21908CB3","#21908CB5","#21908CB8","#21908CBA","#21908CBD","#21908CBF","#21908CC2","#21908CC4","#21908CC7","#21908CC9","#21908CCC","#21908CCF","#21908CD1","#21908CD4","#21908CD6","#21908CD9","#21908CDB","#21908CDE","#21908CE0","#21908CE3","#21908CE6","#21908CE8","#21908CEB","#21908CED","#21908CF0","#21908CF2","#21908CF5","#21908CF7","#21908CFA","#21908CFC"), xlab = "", ylab = "", axes = FALSE, add = TRUE)
  box()
  if (length(sitenames) > 1) {
    axis(2, at = 1:dim(comm)[1], labels = sitenames, las = 1, 
         cex.axis = 1, lwd.ticks = 0)
  }
  if (length(speciesnames) > 1) {
    axis(3, at = 1:dim(comm)[2], labels = speciesnames, las = 2, 
         cex.axis = 1, lwd.ticks = 0)
  }
  mtext(xlab, 3, cex = 1.5, line = xline)
  mtext(ylab, 2, cex = 1.5, line = yline)
}

imagine6 <- function (comm, col = col, fill = TRUE, 
                      xlab = "", ylab = "", yline = 2, xline = 2, sitenames = rownames(comm), 
                      speciesnames = colnames(comm), binary = TRUE, add = TRUE) 
{
  reverse <- nrow(comm):1
  comm <- comm[reverse, ]
  par(mar = c(1, 3.5, 11.2, 8))
  
  image(1:dim(comm)[2], 1:dim(comm)[1], t(comm), col = c("#00000000","#44015403","#44015405","#44015408","#4401540A","#4401540D","#4401540F","#44015412","#44015414","#44015417","#4401541A","#4401541C","#4401541F","#44015421","#44015424","#44015426","#44015429","#4401542B","#4401542E","#44015430","#44015433","#44015436","#44015438","#4401543B","#4401543D","#44015440","#44015442","#44015445","#44015447","#4401544A","#4401544D","#4401544F","#44015452","#44015454","#44015457","#44015459","#4401545C","#4401545E","#44015461","#44015463","#44015466","#44015469","#4401546B","#4401546E","#44015470","#44015473","#44015475","#44015478","#4401547A","#4401547D","#44015480","44015482","#44015487","#4401548A","#4401548C","#4401548F","#44015491","#44015494","#44015496","#44015499","#4401549C","#4401549E","#440154A1","#440154A3","#440154A6","#440154A8","#440154AD","#440154B0","#440154B3","#440154B5","#440154B8","#440154BA","#440154BD","#440154BF","#440154C2","#440154C4","#440154C7","#440154C9","#440154CC","#440154CF","#440154D1","#440154D4","#440154D6","#440154D9","#440154DB","#440154DE","#440154E0","#440154E3","#440154E6","#440154E8","#440154EB","#440154ED","#440154F0","#440154F2","#440154F5","#440154F7","#440154FA","#440154FC"), xlab = "", ylab = "", axes = FALSE, add = TRUE)
  box()
  if (length(sitenames) > 1) {
    axis(2, at = 1:dim(comm)[1], labels = sitenames, las = 1, 
         cex.axis = 1, lwd.ticks = 0)
  }
  if (length(speciesnames) > 1) {
    axis(3, at = 1:dim(comm)[2], labels = speciesnames, las = 2, 
         cex.axis = 1, lwd.ticks = 0)
  }
  mtext(xlab, 3, cex = 1.5, line = xline)
  mtext(ylab, 2, cex = 1.5, line = yline)
}

# Ready to create figure...

# Set graphical parameters
par(mar = c(0.55, 22, 10.85, 0.35))


# Make cluster dendrogram with predicted site-level abundances 
pred.site <-read.csv("predsite.csv", header = TRUE, stringsAsFactors = FALSE)
rownames(pred.site) <- pred.site[,1]
pred.site <- pred.site[,-1]

dendo  <- decostand(pred.site, method = "normalize") %>% dist %>% hclust %>% as.dendrogram %>%   set("branches_k_color", k = 3, value = c("grey50","#21908C", "#440154")) %>% set("labels", NA) %>%    set("by_labels_branches_lwd", value = c(1:10)) %>% plot_horiz.dendrogram(axes = FALSE) 

par(new = TRUE) # this line is important or else heatmap will replace dendrogram

imagine4(subgreys1) #old colour scheme, modelled sp counts
imagine5(subblues1)
imagine6(subpurples1)
```







